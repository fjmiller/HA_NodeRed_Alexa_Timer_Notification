[{"id":"cf537c59.09d41","type":"tab","label":"Alexa Timers","disabled":false,"info":""},{"id":"c61c13a5.9c744","type":"server-state-changed","z":"cf537c59.09d41","name":"","server":"e4ec20e4.dd969","version":1,"exposeToHomeAssistant":false,"haConfig":[{"property":"name","value":""},{"property":"icon","value":""}],"entityidfilter":".next_timer","entityidfiltertype":"regex","outputinitially":false,"state_type":"str","haltifstate":"","halt_if_type":"str","halt_if_compare":"is_not","outputs":1,"output_only_on_state_change":true,"x":150,"y":140,"wires":[["166e4854.e91d28"]]},{"id":"166e4854.e91d28","type":"function","z":"cf537c59.09d41","name":"Update Timer Status for Current Device","func":"//Execution Time Variance : Since we are calulcation execution time we have to assume internet latency into the calc.  Nubmer below is second\nexecutionTimeVariance = 5;\n\n//Adjust variance for Milliseconds\nexecutionTimeVariance = 5 * 1000;\noutputMessages = [];\n\n// If global alexaTimerArray does not exist create it\nalexaTimerArray = global.get('alexaTimerArray');\nif (alexaTimerArray === null || alexaTimerArray === undefined)\n { \n    alexaTimerArray=[];\n }\n    \n//Get The Array of Timers associated with the device that just changed \ndeviceTimerArray = JSON.parse(msg.data.new_state.attributes.sorted_all);\n\n//Loop through each active device\ndeviceTimerArray.forEach((timer) => {\n    \n    //Determine if this is a cancelled or paused timer, If so cancel any in progress timers\n    if (timer[1].status === \"OFF\" || timer[1].status === \"PAUSED\")\n    {\n        //Cancel all Running Flows\n        alexaTimerArray.forEach((alexaTimer) => {\n            if (alexaTimer.timerID === timer[0])\n            {\n                alexaTimer.state = \"cancelled\";\n            }\n        })\n    \n        global.set('alexaTimerArray', alexaTimerArray);\n        \n        return;\n    }\n    \n    \n    //Determine if Timer already exists\n    thisGlobalTimer = alexaTimerArray.filter(allTimers => (allTimers.timerID === timer[0] && allTimers.state === \"active\"));\n    msg.filteredArray = thisGlobalTimer;\n    \n    //If Timer Does Not Exist Add It to the Array\n    if (thisGlobalTimer.length === 0)\n    {\n        friendlyNameLen = msg.data.new_state.attributes.friendly_name.length;\n        \n        newTimerArray = { \"timerID\": timer[0],\n                           \"createDate\" : timer[1].createdDate,\n                           \"remainingTime\" : timer[1].remainingTime,\n                           \"executionTime\": Date.now() + timer[1].remainingTime,\n                           \"timerlabel\": timer[1].timerLabel,\n                           \"deviceName\": msg.data.new_state.attributes.friendly_name.substring(0,friendlyNameLen - 11),\n                           \"entity\": msg.data.entity_id,\n                           \"testexecutionTime\": Date.parse(msg.payload),\n                           \"state\": \"active\"\n                        };\n                         \n        alexaTimerArray.push(newTimerArray);\n        newmsg = {\"delay\": timer[1].remainingTime, \"timerArray\": newTimerArray};\n        outputMessages.push(newmsg);\n        \n    }  \n    else{\n      //Check see if we have an Active Timer with a different execution time\n      alexaTimerArray.forEach((alexaTimer) => {\n            if (alexaTimer.timerID === timer[0] &&\n                  alexaTimer.state === \"active\")\n            {\n                \n              if ((Date.now() + timer[1].remainingTime) < (alexaTimer.executionTime - executionTimeVariance)|| (Date.now() + timer[1].remainingTime) > (alexaTimer.executionTime + executionTimeVariance))\n              {\n                alexaTimer.state = \"cancelled\";\n                newTimerArray = { \"timerID\": timer[0],\n                                  \"createDate\" : timer[1].createdDate,\n                                  \"remainingTime\" : timer[1].remainingTime,\n                                  \"executionTime\": Date.now() + timer[1].remainingTime,\n                                  \"timerlabel\": timer[1].timerLabel,\n                                  \"deviceName\": msg.data.new_state.attributes.friendly_name.substring(0,friendlyNameLen - 11),\n                                  \"entity\": msg.data.entity_id,\n                                  \"testexecutionTime\": Date.parse(msg.payload),\n                                  \"state\": \"active\"\n                                };\n                alexaTimerArray.push(newTimerArray);\n                newmsg = {\"delay\": msg.delay = timer[1].remainingTime, \"timerArray\": newTimerArray};\n                outputMessages.push(newmsg);\n              }\n            }\n          \n      })\n      \n    }\n})\n\n//Set the Timer Array to Global\nglobal.set(\"alexaTimerArray\", alexaTimerArray);\nmsg = outputMessages;\n\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":460,"y":140,"wires":[["b70e634f.05f31"]]},{"id":"4957ff60.51cb3","type":"function","z":"cf537c59.09d41","name":"Determine Timer Status and clean alexaTimerArray","func":"//Execution Time Variance : Since we are calulcation execution time we have to assume internet latency into the calc.  Nubmer below is second\nexecutionTimeVariance = 5;\n\n//Adjust variance for Milliseconds\nexecutionTimeVariance = 5 * 1000;\n\nalexaTimerArray = global.get('alexaTimerArray');\n\n//Find our instance in the alexaTimersArray\n  alexaTimerArray.forEach((alexaTimer,index) => {\n            if (alexaTimer.timerID === msg.timerArray[\"timerID\"] &&\n               (msg.timerArray[\"executionTime\"]) >= (alexaTimer.executionTime - executionTimeVariance) &&\n               (msg.timerArray[\"executionTime\"]) <= (alexaTimer.executionTime + executionTimeVariance)\n               )\n            {\n               //We have found an entry\n               \n               //If the entry is cancelled that note that on the message so we don't announce\n               if (alexaTimer.state === \"cancelled\")\n               {\n                   msg.cancelled = \"true\";\n               } \n               \n               //Remove the entry from the array\n               alexaTimerArray.splice(index,1);\n               \n            }\n  })\n\nglobal.set('alexaTimerArray',alexaTimerArray);\n \nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1150,"y":140,"wires":[["4221a935.db51e8"]]},{"id":"b70e634f.05f31","type":"delay","z":"cf537c59.09d41","name":"Delay until Timer Ends","pauseType":"delayv","timeout":"5","timeoutUnits":"seconds","rate":"1","nbRateUnits":"1","rateUnits":"second","randomFirst":"1","randomLast":"5","randomUnits":"seconds","drop":false,"x":780,"y":140,"wires":[["4957ff60.51cb3"]]},{"id":"4221a935.db51e8","type":"switch","z":"cf537c59.09d41","name":"Message Not Cancelled?","property":"cancelled","propertyType":"msg","rules":[{"t":"neq","v":"true","vt":"str"}],"checkall":"true","repair":false,"outputs":1,"x":290,"y":200,"wires":[["972e1394.4aee4"]]},{"id":"aded50ac.4d88a","type":"function","z":"cf537c59.09d41","name":"Clean alexaTimerArray (Orphans can Happen)","func":"//This routine will clean up any entries in alexaTimerArray\n//Orphans can happen if node red gets a hiccup or deploy while a timer delay is going on.\n//In testing the flow itself wasn't leaving orphans and cleaning up as designed.\n\nalexaTimerArray = global.get('alexaTimerArray');\n\n//Find our instance in the alexaTimersArray\n  alexaTimerArray.forEach((alexaTimer,index) => {\n          \n               //ID entries that would have executed by now\n               if (alexaTimer[\"executionTime\"] <  Date.now())\n              {\n               //Remove the entry from the array\n               alexaTimerArray.splice(index,1);\n               \n              }\n  })\n\nglobal.set('alexaTimerArray',alexaTimerArray);\n\n\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":1200,"y":280,"wires":[[]]},{"id":"66a242c2.aec57c","type":"api-call-service","z":"cf537c59.09d41","name":"Call Notify on Alexa Device","server":"e4ec20e4.dd969","version":1,"debugenabled":false,"service_domain":"notify","service":"","entityId":"","data":"","dataType":"json","mergecontext":"","output_location":"payload","output_location_type":"msg","mustacheAltTags":true,"x":740,"y":280,"wires":[["aded50ac.4d88a"]]},{"id":"116092.34144f6f","type":"time-range-switch","z":"cf537c59.09d41","name":"Don't Alert at Night(10pmto8am)","lat":"","lon":"","startTime":"22:00","endTime":"08:00","startOffset":0,"endOffset":0,"x":390,"y":280,"wires":[[],["66a242c2.aec57c"]]},{"id":"41fb2d77.46d724","type":"comment","z":"cf537c59.09d41","name":"Notify on All Alexa Devices if a Timer Goes Off","info":"","x":320,"y":80,"wires":[]},{"id":"972e1394.4aee4","type":"function","z":"cf537c59.09d41","name":"Generate TTS Message","func":"//Generate the TTS Message.  Use keywords for dynamic values.  \n//Valid Valuse\n// {timerLabel} : The Name given to the timer, omitted if null\n// {deviceName} \" The Echo Device Name\n\nmsgTTS= \"a {timerLabel} timer is going off on {deviceName}\"\n\nif (msg.timerArray[\"timerlabel\"] === null || msg.timerArray[\"timerlabel\"] === undefined ){\n    timerLabel = \"\";\n   } \n  else {timerLabel = msg.timerArray[\"timerlabel\"];}\n\n//Perform Transforms\nvar message = msgTTS.replace(\"{timerLabel}\", timerLabel);\nmessage = message.replace(\"{deviceName}\", msg.timerArray[\"deviceName\"]);\n\nmsg.msgTTS = message;\n\n\nreturn msg;","outputs":1,"noerr":0,"initialize":"","finalize":"","x":550,"y":200,"wires":[["db584f14.69a32"]]},{"id":"db584f14.69a32","type":"function","z":"cf537c59.09d41","name":"Determine which Alexa Media to Send to","func":"//Find all entities that start alexa_media, filter out the reporting device\n//Pass the msg and the device to a note for announcements\n//Build the TTS Message for Alexa\n//Message Txt: A {TimerLabel} Timer is going off on {device Friendly Name}\n\nconst allServices = global.get('homeassistant').hassOS.services.notify;\nconst excludeEntities = global.get('homeassistant').hassOS.states['group.services_exlude_from_alexa_timer_notifications'];\n\n\nentities=[];\n\n//Determine Alexa Media Name of entity that timer is from\nalexaMedia = \"alexa_media_\" + (msg.timerArray[\"entity\"].split(\".\"))[1];\nalexaMedia = alexaMedia.substring(0, alexaMedia.length - 11);\n\nmsg.alexaMedia = alexaMedia;\n\nfor(var service in allServices){\n   \n      //Make Sure all Timers start with Alexa_media\n      if (service.startsWith(\"alexa_media\"))\n      {\n            //Strip out all member os the group we specifically excluded\n            if ((excludeEntities.attributes.entity_id.indexOf(\"notify.\" + service)) == -1)\n             //Strip out the device the Timer is On\n             if (alexaMedia !== service)\n               entities.push(service);\n      }        \n}\n\nnewPayload=[];\nfor(i=0; i<entities.length; i++)\n{ \n    \n\n   var payloadentry = {\"service\": entities[i],\n                   \"data\":{\n                       \"message\": msg.msgTTS,\n                       \"data\":{\"type\":\"tts\"}\n                          }\n                  };\n    \n    var newmsg={payload: payloadentry, topic:msg.topic}\n    \n    newPayload.push(newmsg);\n    \n}\n\n\nreturn [newPayload];","outputs":1,"noerr":0,"initialize":"","finalize":"","x":880,"y":200,"wires":[["116092.34144f6f"]]},{"id":"e4ec20e4.dd969","type":"server","z":"","name":"HassOS","legacy":false,"addon":true,"rejectUnauthorizedCerts":true,"ha_boolean":"y|yes|true|on|home|open","connectionDelay":false,"cacheJson":true}]